----------------------------------------------------------------------------------------------------
gptme/tools/shell.py
  1│"""
...⋮...
117│class ShellSession:
118│    process: subprocess.Popen
...⋮...
147│    def run(self, code: str, output=True) -> tuple[int | None, str, str]:
148│        """Runs a command in the shell and returns the output."""
   │        # TODO(jake|issue:108): Modify split_commands function to preserve heredoc syntax
149│        commands = split_commands(code)
...⋮...
161│    def _run(self, command: str, output=True, tries=0) -> tuple[int | None, str, str]:
162│        assert self.process.stdin
163│
164│        # run the command
   │        # TODO(jake|issue:108): Remove delimiter for heredoc commands
165│        full_command = f"{command}; echo ReturnCode:$? {self.delimiter}\n"
   │        # TODO(jake|issue:108): Implement multi-line command handling
166│        try:
167│            self.process.stdin.write(full_command)
168│        except BrokenPipeError:
169│            # process has died
170│            if tries == 0:
171│                # log warning and restart, once
172│                logger.warning("Warning: shell process died, restarting")
173│                self.restart()
174│                return self._run(command, output=output, tries=tries + 1)
175│            else:
176│                raise
177│
178│        self.process.stdin.flush()
179│
180│        stdout = []
181│        stderr = []
182│        return_code = None
183│        read_delimiter = False
184│
   │        # TODO(jake|issue:108): Implement heredoc-aware command completion detection
185│        while True:
186│            rlist, _, _ = select.select([self.stdout_fd, self.stderr_fd], [], [])
187│            for fd in rlist:
188│                assert fd in [self.stdout_fd, self.stderr_fd]
189│                # We use a higher value, because there is a bug which leads to spaces at the boundary
190│                # 2**12 = 4096
191│                # 2**16 = 65536
192│                data = os.read(fd, 2**16).decode("utf-8")
193│                re_returncode = re.compile(r"ReturnCode:(\d+)")
194│                for line in re.split(r"(\n)", data):
195│                    if match := re_returncode.match(line):
196│                        return_code = int(match.group(1))
197│                    if self.delimiter in line:
198│                        read_delimiter = True
199│                        continue
200│                    if fd == self.stdout_fd:
201│                        stdout.append(line)
202│                        if output:
203│                            print(line, end="", file=sys.stdout)
204│                    elif fd == self.stderr_fd:
205│                        stderr.append(line)
206│                        if output:
207│                            print(line, end="", file=sys.stderr)
208│            if read_delimiter:
209│                break
210│
211│        # if command is cd and successful, we need to change the directory
212│        if command.startswith("cd ") and return_code == 0:
213│            ex, pwd, _ = self._run("pwd", output=False)
214│            assert ex == 0
215│            os.chdir(pwd.strip())
216│
217│        return (
218│            return_code,
219│            "".join(stdout).replace(f"ReturnCode:{return_code}", "").strip(),
220│            "".join(stderr).strip(),
221│        )
...⋮...
   │# TODO(jake|issue:108): Update split_commands to handle heredoc syntax
   │# - Detect start of heredoc (<<, <<-, <<< operators)
   │# - Preserve heredoc content until end delimiter is found
   │# - Return commands as a list of potentially multi-line strings
419│def split_commands(script: str) -> list[str]:
420│    # TODO: write proper tests
421│    parts = bashlex.parse(script)
422│    commands = []
423│    for part in parts:
424│        if part.kind == "command":
425│            command_parts = []
426│            for word in part.parts:
427│                start, end = word.pos
428│                command_parts.append(script[start:end])
429│            command = " ".join(command_parts)
430│            commands.append(command)
431│        elif part.kind == "compound":
432│            for node in part.list:
433│                command_parts = []
434│                for word in node.parts:
435│                    start, end = word.pos
436│                    command_parts.append(script[start:end])
437│                command = " ".join(command_parts)
438│                commands.append(command)
439│        elif part.kind in ["function", "pipeline", "list"]:
440│            commands.append(script[part.pos[0] : part.pos[1]])
441│        else:
442│            logger.warning(
443│                f"Unknown shell script part of kind '{part.kind}', hoping this works"
444│            )
445│            commands.append(script[part.pos[0] : part.pos[1]])
446│    return commands
...⋮...

----------------------------------------------------------------------------------------------------
tests/test_shell.py
  1│import os
...⋮...
   │# TODO(jake|issue:108): Expand test_echo_multiline to include heredoc syntax
   │# - Test basic heredoc (<<)
   │# - Test stripped heredoc (<<-)
   │# - Test here-string (<<<)
 28│def test_echo_multiline(shell):
 29│    # tests multiline and trailing + leading whitespace
 30│    ret, out, err = shell.run("echo 'Line 1  \n  Line 2'")
 31│    assert err.strip() == ""  # Expecting no stderr
 32│    assert (
 33│        out.strip() == "Line 1  \n  Line 2"
 34│    )  # Expecting stdout to be "Line 1\nLine 2"
 35│    assert ret == 0
...⋮...
   │# TODO(jake|issue:108): Add new test for complex heredoc scenarios
   │# def test_heredoc_complex():
   │# Test nested heredocs
   │# Test heredoc with variable substitution
   │# Test heredoc in a pipeline
 96│def test_pipeline():
 97│    script = """
 98│echo "Hello, World!" | wc -w
 99│"""
100│    shell = ShellSession()
101│    ret, out, err = shell.run(script)
102│    assert ret == 0
103│    assert out.strip() == "2"